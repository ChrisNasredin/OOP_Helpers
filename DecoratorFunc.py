def decorator(func): # декоратор ожидает функцию без без запуска в качестве аргументв
    '''Самая базовая декорирующая функция'''
    def inner(*args, **kwargs):
        print('Before code')
        print(func(*args, **kwargs))
        print('After code')
    return inner

def sq(a, b):
    return a ** b

a = decorator(sq)
'''
    после этого действия в указателе а хранится функция inner, к которой в
    виде замыкания присоединенен обьект функции sq.
    При исполнении функции inner произойдет следующее:
    функция inner примет все аргументы и выполнит код:
        print('Before code')
        <присоединенная функция>(*args, kwargs)
        print('After code')
    при этом аргументы, которая функция примет, он передаст без
    изменений в запомненную в качестве состояния функцию
'''

sq = decorator(sq) # аналогично @decorator над объявлением функции
'''
    Переназначем переменную функции на декорированную - в данный момент
    в имени sq содержится функция inner c присоединенным обьектом функции,
    которая вычисляет степени, но имя sq уже не ссылается на нее. в этот 
    момент на нее ссылается имя func, которое является локальной переменной
    в области видимости функции decorator
'''
sq(2,3)